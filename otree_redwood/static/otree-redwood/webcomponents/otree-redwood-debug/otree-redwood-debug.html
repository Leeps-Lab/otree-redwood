<link
	rel="import"
	href="/static/bower_components/polymer/polymer.html" />


<dom-module id="otree-redwood-debug">

	<template>
		<style>
			:host {
				display: block;
			}
		</style>
		<div id="chart"></div>
	</template>

	<script>
		Polymer({
			is: 'otree-redwood-debug',
			properties: {
				session: {
					type: String,
				},
				events: {
					type: Array,
					value: () => {
						return [];
					}
				}
			},
			ready() {
				let protocol = 'ws://';
				if (window.location.protocol === 'https:') {
					protocol = 'wss://';
				}
				const addr = (
					protocol +
					window.location.host +
					'/redwood/events/session/' + this.session);
				this.socket = new ReconnectingWebSocket(addr, null, {
					timeoutInterval: 10000
				});
				this.socket.onerror = this.onError.bind(this);
				this.socket.onmessage = this.onMessage.bind(this);
				$.getJSON('/redwood/api/events/session/' + this.session).done((events) => {
					this.set('events', events);
					window.requestAnimationFrame(this._update.bind(this));
				});

				this.graph = Highcharts.chart({
					chart: {
						animation: true,
						renderTo: this.$.chart,
						width: this.offsetWidth,
						height: this.offsetHeight
					},
					title: { text: null },
					exporting: { enabled: true },
					tooltip: { enabled: true },
					legend: { enabled: true },
					credits: { enabled: false },
					xAxis: {
						type: 'datetime',
						dateTimeLabelFormats: {
							second: '%H:%M:%S'
						}
					},
					yAxis: {
						title: { text: '' },
					},
					plotOptions: {
						series: {
							states: {
								hover: {
									enabled: true,
								}
							}
						}
					},
					line: {
						marker: {
							enabled: false,
							states: {
								hover: { enabled: false },
								select: { enabled: false }
							}
						}
					},
					series: [
						{
							name: 'Total Events Per Second',
							type: 'area',
							data: [],
						},
					]
				});
			},
			onError(err) {
				console.error(err);
			},
			onMessage(message) {
				const event = JSON.parse(message.data);
				this.events.push(event);
			},
			_update() {
				let bucketStartTime = this.events[0].timestamp;
				const bucketSize = 1000; // 1 seconds, in millis
				const buckets = [];
				buckets.push([bucketStartTime, 0]);
				for (let i = 0; i < this.events.length; i++) {
					const e = this.events[i];
					if (e.channel == 'state') {
						this.graph.xAxis[0].addPlotBand({
							value: e.timestamp,
							width: 1,
							color: 'blue',
							label: {
								text: e.value,
								layout: 'vertical',
							}
						});
					}
					while (e.timestamp - bucketStartTime > bucketSize) {
						bucketStartTime += bucketSize;
						buckets.push([bucketStartTime, 0]);
					}
					buckets[buckets.length-1][1] += 1;
				}
				// Remove the last bucket because it still might be collecting events.
				buckets.splice(buckets.length-1, 1);
				this.graph.series[0].setData(buckets);
				window.requestAnimationFrame(this._update.bind(this));
			}
		});
	</script>

</dom-module>
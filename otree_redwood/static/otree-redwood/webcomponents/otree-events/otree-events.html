<link
	rel="import"
	href="/static/bower_components/polymer/polymer.html" />

<link
	rel="import" 
	href="/static/otree-redwood/webcomponents/otree-constants/otree-constants.html">

<dom-module id="otree-events">

	<template>
    	<otree-constants id="constants"></otree-constants>
	</template>

	<script src="/static/otree-redwood/js/debug.js"></script>
	<script>
		var socket = null;
		var listeners = [];

		function onError(error) {
			listeners.forEach(l => {
				l.onError(error);
			});
		}

		function onClose(event) {
			listeners.forEach(l => {
				l.onClose(event);
			});
		}

		function onOpen(event) {
			listeners.forEach(l => {
				l.onOpen(event);
			});
		}

		function onMessage(message) {
			const event = JSON.parse(message.data);
			if ('last_on_channel' in event) {
				for (channel in event.last_on_channel) {
					const msg = event.last_on_channel[channel];
					debug.log(`last on channel: ${channel}\n${JSON.stringify(msg)}`);
					listeners.forEach(l => {
						l.fire('event', msg, {bubbles: false});
					});
				}
				return;
			}
			debug.log(`received event on channel: ${event.channel}\n${JSON.stringify(event.payload)}`);
			listeners.forEach(l => {
				l.fire('event', event, {bubbles: false});
			});
		}

		Polymer({
			is: 'otree-events',
			ready() {
				if (socket === null) {
					let protocol = 'ws://';
					if (window.location.protocol === 'https:') {
						protocol = 'wss://';
					}
					socket = new ReconnectingWebSocket(
						protocol +
						window.location.host +
						'/otree/redwood' +
						'/session/' + this.$.constants.session +
						'/subsession/' + this.$.constants.subsession +
						'/round/' + this.$.constants.round +
						'/group/' + this.$.constants.group +
						'/participant/' + this.$.constants.participantCode +
						'/', null, {
							debug: true,
							timeoutInterval: 10000
						});
					socket.onerror = onError;
					socket.onopen = onOpen;
					socket.onmessage = onMessage;
					socket.onclose = onClose;
				}
				this.socket = socket;
				this.pending = [];
			},
			attached() {
				listeners.push(this);
			},
			detached() {
				listeners.splice(listeners.indexOf(this), 1);
			},
			onOpen() {
				debug.log('socket open');
				this.pending.forEach(msg => {
					this.socket.send(msg);
				});
			},
			onClose() {
				debug.error('socket closed');
			},
			onError(err) {
				debug.error(err);
			},
			send(channel, value) {
				debug.log(`sending on channel ${channel}: ${value}`);
				const msg = JSON.stringify({
					'channel': channel,
					'payload': value
				});
				if (this.socket.readyState != 1) {
					debug.log('not connected... pushing value onto pending stack');
					this.pending.push(msg);
					return;
				}
				this.socket.send(msg);
			}
		});
	</script>

</dom-module>